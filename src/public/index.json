
[{"content":" # ","date":"2025-08-02","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/pygame/","section":"标签","summary":"","title":"Pygame","type":"tags"},{"content":" 一.pygame简介 # Pygame 是一种流行的Python游戏开发库，它提供了许多功能，使开发人员可以轻松创建2D游戏。它具有良好的跨平台支持，可以在多个操作系统上运行，例如Windows，MacOS和Linux 二.环境配置 # 2.1 pygame安装 # * Pygame的安装非常简单，只需要使用pip命令即可。 pip install pygame 2.2 导入库 # import pygame 2.3 检查结果 # print(pygame.ver) 三 基本用法介绍 # 3.1.1 计算坐标系（Computer coordinate system） # 对于2D坐标系而言，只需要需要确定原点，以及规定坐标轴的方向即可。 在2D坐标系中对点的定位，可用（x,y）表示，x表示x轴上的分量也是到y轴的距离，同理y表示y轴上的分量也是到x轴的距离 （x，y）坐标表示中，x y的大小代表距离，x y的正负则代表方向 pygame中的坐标系中原点在左上角(0,0)，x轴水平向右，逐渐增加,反之减少，y轴水平向下，逐渐增加，反之减少。 3.1.2 pygame基础库（Pygame Library） # Pygame提供了各种游戏开发所需的工具和功能。Pygame在SDL（Simple Direct Media Layer，使用C语言编写的多媒体开发库）的基础上开发而成，它提供了诸多操作模块，比如图像模块（image）、声音模块（mixer）、输入/输出（鼠标、键盘、显示屏）模块等。相比于开发3D游戏而言，Pygame更擅长开发2D游戏， 3.1.3 基本流程 # 3.1.3.1 初始化 # import pygame pygame.init() # 要使用pygame提供的所有功能之前,需要调用init方法 3.1.3.2 颜色填充 # Pygame使用的颜色系统是很多计算机语言和程序的通用系统，称为RGB（red, green, blue），Pygame还提供了一个命名颜色的列表，也可以自行定义颜色。\ncolors = [color for color in pygame.color.THECOLORS.keys()] colors # 定义程序所需颜色变量 BLACK = ( 0, 0, 0) WHITE = ( 255, 255, 255) GREEN = ( 0, 255, 0) RED = ( 255, 0, 0) BLUE = ( 0, 0, 255) GRAY = ( 123, 112, 113) SKYBLUE = ( 65, 146, 247) CRIMSON = ( 234, 51, 35) 3.1.3.3 窗口初始化 # pygame提供了一个模块pygame.display用于创建,管理游戏窗口\n# 初始化游戏窗口 SCREEN_WIDTH = 600 SCREEN_HEIGHT = 400 screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) pygame.display.set_caption(\u0026#34;初始化pygame窗口\u0026#34;) 3.1.3.4 游戏循环 # done = False # 退出游戏标志位 clock = pygame.time.Clock() # 控制游戏帧率 # -------- 主循环 ----------- while not done: # --- 实现监听 for event in pygame.event.get(): if event.type == pygame.QUIT: done = True pygame.quit() #卸载所有模块 sys.exit() #终止程序，确保退出程序 # --- 游戏逻辑 # --- 游戏图形绘制 screen.fill(WHITE) # 清空屏幕 pygame.display.flip() # 更新屏幕内容 clock.tick(60) #限制每秒刷新60次 3.2 pygame图形学相关 # 3.2.1 基本图元绘制 # 目前主流的显示器上，是采用光栅扫描显示，所有图形的显示都归结为按照图形的描述将显示设备的光栅像素点点亮。为了输出一个像素，需要将该像素的坐标和颜色信息转换成输出设别的相应指令。通俗的理解，其是由各个像素点组成的画面。\n而基本图元显示问题是根据基本图元的描述信息来生产像素组合。基本二维图形图元包括点、线、圆弧、多边形、字体符号和位图等。\n# 查看draw模块下可用的方法 [\u0026#34;pygame.draw.%s\u0026#34; % method for method in dir(pygame.draw) if not method.startswith(\u0026#34;__\u0026#34;)] 3.2.1.1 绘制直线 # help(pygame.draw.line) Help on built-in function line in module pygame.draw: line(...) line(surface, color, start_pos, end_pos) -\u0026gt; Rect line(surface, color, start_pos, end_pos, width=1) -\u0026gt; Rect draw a straight line import math \u0026#34;\u0026#34;\u0026#34; 绘制主循环 \u0026#34;\u0026#34;\u0026#34; run = True while run: screen.fill((255, 255, 255)) pygame.draw.line(screen, BLACK, [50, 50], [300, 300], 5) pygame.draw.line(screen, BLACK, [550, 50], [300, 300], 5) pygame.draw.line(screen, BLACK, [50, 50], [550, 50], 3) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.flip() pygame.quit() 3.2.1.2 绘制矩形 # help(pygame.draw.rect) Help on built-in function rect in module pygame.draw: rect(...) rect(surface, color, rect) -\u0026gt; Rect rect(surface, color, rect, width=0, border_radius=0, border_top_left_radius=-1, border_top_right_radius=-1, border_bottom_left_radius=-1, border_bottom_right_radius=-1) -\u0026gt; Rect draw a rectangle \u0026#34;\u0026#34;\u0026#34; 绘制主循环 \u0026#34;\u0026#34;\u0026#34; run = True while run: screen.fill((255, 255, 255)) pygame.draw.rect(screen,BLACK,[20,20,250,100],2) # pygame.draw.rect(screen, (255, 0, 0), (200, 100, 150, 150)) # 绘制 # pygame.draw.rect(screen, (255, 0, 0), (200, 100, 150, 150), border_radius = 50, width = 5) # 绘制 - 圆边 # pygame.draw.rect(screen, (255, 0, 0), (200, 100, 150, 150), width = 5, border_bottom_right_radius = 50, border_top_left_radius = 25) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.flip() pygame.quit() 3.2.1.3 绘制圆圈 # help(pygame.draw.circle) Help on built-in function circle in module pygame.draw: circle(...) circle(surface, color, center, radius) -\u0026gt; Rect circle(surface, color, center, radius, width=0, draw_top_right=None, draw_top_left=None, draw_bottom_left=None, draw_bottom_right=None) -\u0026gt; Rect draw a circle \u0026#34;\u0026#34;\u0026#34; 绘制主循环 \u0026#34;\u0026#34;\u0026#34; run = True while run: screen.fill((255, 255, 255)) pygame.draw.circle(screen, (0, 0, 0), (300, 200), 75) # 绘制圆形 # pygame.draw.circle(screen, (255, 255, 0), (300, 200), 75, draw_top_right = True, draw_bottom_left = True) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.flip() pygame.quit() 3.2.1.4 绘制椭圆形 # help(pygame.draw.ellipse) Help on built-in function ellipse in module pygame.draw: ellipse(...) ellipse(surface, color, rect) -\u0026gt; Rect ellipse(surface, color, rect, width=0) -\u0026gt; Rect draw an ellipse \u0026#34;\u0026#34;\u0026#34; 绘制主循环 \u0026#34;\u0026#34;\u0026#34; run = True while run: screen.fill((255, 255, 255)) pygame.draw.ellipse(screen, BLACK, [20,20,250,100], 2) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.flip() pygame.quit() 3.2.1.5 绘制圆弧 # help(pygame.draw.arc) Help on built-in function arc in module pygame.draw: arc(...) arc(surface, color, rect, start_angle, stop_angle) -\u0026gt; Rect arc(surface, color, rect, start_angle, stop_angle, width=1) -\u0026gt; Rect draw an elliptical arc \u0026#34;\u0026#34;\u0026#34; 绘制主循环 \u0026#34;\u0026#34;\u0026#34; run = True while run: screen.fill((255, 255, 255)) pygame.draw.arc(screen, (0, 255, 255), (200, 100, 150, 150), 0, 3.14, width = 5) # 绘制圆弧 for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.flip() pygame.quit() 3.2.1.6 绘制多边形 # help(pygame.draw.polygon) Help on built-in function polygon in module pygame.draw: polygon(...) polygon(surface, color, points) -\u0026gt; Rect polygon(surface, color, points, width=0) -\u0026gt; Rect draw a polygon \u0026#34;\u0026#34;\u0026#34; 绘制主循环 \u0026#34;\u0026#34;\u0026#34; run = True while run: screen.fill((255, 255, 255)) pygame.draw.polygon(screen, BLACK, [[100,100], [0,200], [200,200]], 5) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.flip() pygame.quit() 3.2.1.7 绘制文字 # \u0026#34;\u0026#34;\u0026#34; 绘制主循环 \u0026#34;\u0026#34;\u0026#34; run = True while run: screen.fill((255, 255, 255)) font = pygame.font.SysFont(\u0026#39;Calibri\u0026#39;, 25, True, False) text = font.render(\u0026#34;Hello World!\u0026#34;,True,BLACK) screen.blit(text, [250, 250]) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.flip() pygame.quit() 3.2.2 二维基本几何变换 # 图形学中，基本的几何变换主要有缩放、错切、旋转、反射、平移等几个操作。其他的复杂变换可以通过这些基础变换组合实现。 # pygame二维变换相关方法 [\u0026#34;pygame.transform.%s\u0026#34; % method for method in dir(pygame.transform) if not method.startswith(\u0026#34;__\u0026#34;)] 3.2.2.1 平移变换 # pygame实现通过改变绘制图案位置来进行对其的平移变换。\nimport math # 初始化物体形状 image = pygame.Surface((50, 50)) image.fill((255, 255, 255)) clock = pygame.time.Clock() # 获取图片原始宽高 rect = image.get_rect() rect.x = 100 # 初始化位移参数 rect.y = 100 speed = 5 FPS = 60 \u0026#34;\u0026#34;\u0026#34; 移动物体方法 \u0026#34;\u0026#34;\u0026#34; def move(dx, dy): rect.x += dx * speed rect.y += dy * speed \u0026#34;\u0026#34;\u0026#34; 控制物体运动Demo循环 \u0026#34;\u0026#34;\u0026#34; run = True while run: for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.quit() keys = pygame.key.get_pressed() if keys[pygame.K_RIGHT]: move(1, 0) if keys[pygame.K_LEFT]: move(-1, 0) if keys[pygame.K_UP]: move(0, -1) if keys[pygame.K_DOWN]: move(0, 1) screen.fill(BLACK) screen.blit(image, rect) pygame.display.flip() clock.tick(FPS) 3.2.2.2 比例变换 # help(pygame.transform.scale) Help on built-in function scale in module pygame.transform: scale(...) scale(surface, size, dest_surface=None) -\u0026gt; Surface resize to new resolution import math # 初始化物体 dino = pygame.image.load(\u0026#34;assets/geometric-transformation/images/dino.png\u0026#34;).convert_alpha() x = 300 y = 200 # 获取图片原始宽高 w = dino.get_width() h = dino.get_height() \u0026#34;\u0026#34;\u0026#34; 旋转物体控制主循环 \u0026#34;\u0026#34;\u0026#34; run = True while run: screen.fill(WHITE) pos = pygame.mouse.get_pos() w = dino.get_width() h = dino.get_height() # 原始图片 origin_dino = pygame.transform.scale(dino, (w, h )) dino_rect = dino.get_rect(center = (x-20, y)) screen.blit(origin_dino, dino_rect) # 缩小图片 resized_dino_small = pygame.transform.scale(dino, (w * 0.5, h * 0.5)) dino_rect = dino.get_rect(center = (x-120, y+60)) screen.blit(resized_dino_small, dino_rect) # 放大图片 resized_dino_big = pygame.transform.scale(dino, (w * 1.5, h * 1.5)) dino_rect = dino.get_rect(center = (x+120, y-60)) screen.blit(resized_dino_big, dino_rect) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.flip() 3.2.2.3 旋转变换 # help(pygame.transform.rotate) Help on built-in function rotate in module pygame.transform: rotate(...) rotate(surface, angle) -\u0026gt; Surface rotate an image import math \u0026#34;\u0026#34;\u0026#34; 初始化物体 \u0026#34;\u0026#34;\u0026#34; turret_original = pygame.image.load(\u0026#34;assets/geometric-transformation/images/Handgun1.png\u0026#34;).convert_alpha() x = 300 y = 200 \u0026#34;\u0026#34;\u0026#34; 旋转物体控制主循环 \u0026#34;\u0026#34;\u0026#34; run = True while run: screen.fill(GRAY) pos = pygame.mouse.get_pos() x_dist = pos[0] - x y_dist = -(pos[1] - y) angle = math.degrees(math.atan2(y_dist, x_dist)) turret = pygame.transform.rotate(turret_original, angle) turret_rect = turret.get_rect(center = (x, y)) screen.blit(turret, turret_rect) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.flip() 3.2.2.4 对称变换 # help(pygame.transform.flip) Help on built-in function flip in module pygame.transform: flip(...) flip(surface, flip_x, flip_y) -\u0026gt; Surface flip vertically and horizontally import math # 初始化物体 dino = pygame.image.load(\u0026#34;assets/geometric-transformation/images/dino.png\u0026#34;).convert_alpha() x = 300 y = 200 # 获取图片原始宽高 w = dino.get_width() h = dino.get_height() is_flip = False \u0026#34;\u0026#34;\u0026#34; 旋转物体控制主循环 \u0026#34;\u0026#34;\u0026#34; run = True while run: screen.fill(CRIMSON) pos = pygame.mouse.get_pos() key = pygame.key.get_pressed() if key[pygame.K_LEFT]: is_flip = True if key[pygame.K_RIGHT]: is_flip = False flipped_dino = pygame.transform.flip(dino, is_flip, False) dino_rect = dino.get_rect(center = (x-40 if is_flip else x, y)) screen.blit(flipped_dino, dino_rect) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.flip() 3.3 精灵图（Sprite） # 3.3.1 精灵图集 # Sprite sheet是按网格排列的精灵(Sprite)集合。然后将这些精灵(Sprite)编译成一个动画剪辑(Animation Clip)，按顺序播放每个精灵(Sprite)，以创建动画效果，就像翻书一样。\n3.3.1.2 加载精灵图集 # help(pygame.image.load) Help on built-in function load in module pygame.image: load(...) load(filename) -\u0026gt; Surface load(fileobj, namehint=) -\u0026gt; Surface load new image from a file (or file-like object) \u0026#34;\u0026#34;\u0026#34; 加载资源 \u0026#34;\u0026#34;\u0026#34; pygame.display.set_caption(\u0026#39;精灵图集\u0026#39;) sprite_sheet_image = pygame.image.load(\u0026#39;assets/spritesheet/doux.png\u0026#39;).convert_alpha() \u0026#34;\u0026#34;\u0026#34; 定义精灵图集类并初始化 \u0026#34;\u0026#34;\u0026#34; class SpriteSheet(): def __init__(self, image): self.sheet = image def get_image(self, frame, width, height, scale, colour): image = pygame.Surface((width, height)).convert_alpha() image.blit(self.sheet, (0, 0), ((frame * width), 0, width, height)) image = pygame.transform.scale(image, (width * scale, height * scale)) image.set_colorkey(colour) return image sprite_sheet = SpriteSheet(sprite_sheet_image) \u0026#34;\u0026#34;\u0026#34; 处理原始图集 \u0026#34;\u0026#34;\u0026#34; BG = (50, 50, 50) frame_0 = sprite_sheet.get_image(0, 24, 24, 3, BLACK) frame_1 = sprite_sheet.get_image(1, 24, 24, 3, BLACK) frame_2 = sprite_sheet.get_image(2, 24, 24, 3, BLACK) frame_3 = sprite_sheet.get_image(3, 24, 24, 3, BLACK) \u0026#34;\u0026#34;\u0026#34; 将处理后的图集绘制屏幕 \u0026#34;\u0026#34;\u0026#34; run = True while run: screen.fill(BG) screen.blit(frame_0, (0, 0)) screen.blit(frame_1, (72, 0)) screen.blit(frame_2, (150, 0)) screen.blit(frame_3, (250, 0)) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.update() pygame.quit() 3.3.1.2 动画帧实现 # 3.3.1.2.1 基础图集动画\n\u0026#34;\u0026#34;\u0026#34; 将图集加载在列表，方便动画制作 \u0026#34;\u0026#34;\u0026#34; animation_list = [] animation_steps = [4,6,3,4] action = 1 last_update = pygame.time.get_ticks() animation_cooldown = 75 frame = 0 step_counter = 0 for animation in animation_steps: temp_img_list = [] for _ in range(animation): temp_img_list.append(sprite_sheet.get_image(step_counter, 24, 24, 3, BLACK)) step_counter += 1 animation_list.append(temp_img_list) \u0026#34;\u0026#34;\u0026#34; 实现动作逻辑\u0026#34;\u0026#34;\u0026#34; run = True while run: screen.fill(BG) current_time = pygame.time.get_ticks() if current_time - last_update \u0026gt;= animation_cooldown: frame += 1 last_update = current_time if frame \u0026gt;= len(animation_list): frame = 0 for event in pygame.event.get(): if event.type == pygame.QUIT: run = False screen.blit(animation_list[action][frame], (0,0)) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.update() pygame.quit() 3.3.1.2.2 背景卷轴动画\n背景卷轴是2D横版游戏的里程碑技术（Defender、Super Mario Bro）。\n而实现2D卷轴，除了控制景深摄像机的移动之外还可以通过移动背景图实现卷轴效果.\n\u0026#34;\u0026#34;\u0026#34; 初始化程序窗体 \u0026#34;\u0026#34;\u0026#34; clock = pygame.time.Clock() FPS = 60 SCREEN_WIDTH = 800 SCREEN_HEIGHT = 432 screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) pygame.display.set_caption(\u0026#34;mmm\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 初始化卷轴动画相关素材 \u0026#34;\u0026#34;\u0026#34; scroll = 0 ground_image = pygame.image.load(\u0026#34;assets/parallax/images/ground.png\u0026#34;).convert_alpha() ground_width = ground_image.get_width() ground_height = ground_image.get_height() bg_images = [] for i in range(1, 6): bg_image = pygame.image.load(f\u0026#34;assets/parallax/images/plx-{i}.png\u0026#34;).convert_alpha() bg_images.append(bg_image) bg_width = bg_images[0].get_width() \u0026#34;\u0026#34;\u0026#34; 绘制背景相关方法 \u0026#34;\u0026#34;\u0026#34; def draw_bg(): for x in range(5): speed = 1 for i in bg_images: screen.blit(i, ((x * bg_width) - scroll * speed, 0)) speed += 0.2 def draw_ground(): for x in range(15): screen.blit(ground_image, ((x * ground_width) - scroll * 2.5, SCREEN_HEIGHT - ground_height)) \u0026#34;\u0026#34;\u0026#34; 主程序循环 \u0026#34;\u0026#34;\u0026#34; run = True while run: clock.tick(FPS) draw_bg() draw_ground() key = pygame.key.get_pressed() if key[pygame.K_LEFT] and scroll \u0026gt; 0: scroll -= 5 if key[pygame.K_RIGHT] and scroll \u0026lt; 3000: scroll += 5 for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.update() pygame.quit() 3.4 UI # 3.4.1 导入所需库 # import pygame import random 3.4.2 初始化窗体 # SCREEN_WIDTH = 800 SCREEN_HEIGHT = 450 screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) pygame.display.set_caption(\u0026#39;界面相关\u0026#39;) 3.4.3 资源加载 # start_img = pygame.image.load(\u0026#39;assets/ui_interation/images/start_btn.png\u0026#39;).convert_alpha() exit_img = pygame.image.load(\u0026#39;assets/ui_interation/images/exit_btn.png\u0026#39;).convert_alpha() 3.4.4 基础实体类 # class Button(): def __init__(self, x, y, image, scale): width = image.get_width() height = image.get_height() self.image = pygame.transform.scale(image, (int(width * scale), int(height * scale))) self.rect = self.image.get_rect() self.rect.topleft = (x, y) self.clicked = False def draw(self, surface): action = False pos = pygame.mouse.get_pos() if self.rect.collidepoint(pos): if pygame.mouse.get_pressed()[0] == 1 and self.clicked == False: self.clicked = True action = True if pygame.mouse.get_pressed()[0] == 0: self.clicked = False surface.blit(self.image, (self.rect.x, self.rect.y)) return action start_button = Button(100, 200, start_img, 0.8) exit_button = Button(450, 200, exit_img, 0.8) 3.4.5 界面交互(按钮点击) # run = True while run: screen.fill((202, 228, 241)) if start_button.draw(screen): print(\u0026#39;开始按钮被点击\u0026#39;) if exit_button.draw(screen): print(\u0026#39;退出按钮被点击\u0026#39;) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False pygame.display.update() pygame.quit() 3.3.6 界面交互（拖拽UI） # \u0026#34;\u0026#34;\u0026#34; 初始化放置物品 \u0026#34;\u0026#34;\u0026#34; active_box = None boxes = [] for i in range(5): x = random.randint(50, 700) y = random.randint(50, 350) w = random.randint(35, 65) h = random.randint(35, 65) box = pygame.Rect(x, y, w, h) boxes.append(box) \u0026#34;\u0026#34;\u0026#34; 实现碰撞检测和鼠标按键监听 \u0026#34;\u0026#34;\u0026#34; run = True while run: screen.fill(\u0026#34;white\u0026#34;) for box in boxes: pygame.draw.rect(screen, \u0026#34;pink\u0026#34;, box) for event in pygame.event.get(): if event.type == pygame.MOUSEBUTTONDOWN: if event.button == 1: for num, box in enumerate(boxes): if box.collidepoint(event.pos): active_box = num if event.type == pygame.MOUSEBUTTONUP: if event.button == 1: active_box = None if event.type == pygame.MOUSEMOTION: if active_box != None: boxes[active_box].move_ip(event.rel) if event.type == pygame.QUIT: run = False pygame.display.flip() pygame.quit() 3.4 音效 # Pygame可以加载多种类型的音频文件，如WAV、MP3等。主要通过pygame.mixer模块来实现对音效的处理,该模块可以依据命令播放一个或多个声音，并且也可以将这些声音混合在一起。\npygame主要处理两种声音，一种是背景音乐，一种是音效。\n# 播放音效 sound = pygame.mixer.Sound(\u0026#39;./assets/audio/bullet.wav\u0026#39;) sound.set_volume(0.9) pygame.mixer.Sound.play(sound) # 播放背景音乐 music = pygame.mixer.music.load(\u0026#39;./assets/audio/mario.mp3\u0026#39;) pygame.mixer.music.play(-1) # 关闭背景音乐 pygame.mixer.music.stop() 四.项目实战 # 4.1 分形图-模拟类 # 曼德勃罗集合（Mandelbrot set）是一个在复平面上定义的数学集合，以法国数学家Benoit Mandelbrot的名字命名。它是由一系列复数构成的，每个复数代表平面上的一个点。\n曼德勃罗集合中的点具有特定的性质，对于某些点，当它们通过迭代计算的方式进行运算时，结果会趋于无穷大。而对于其他点，计算结果则会保持有限。其可以通过迭代计算来确定。对于每个复数c，我们将其作为初始值z0，并通过以下公式进行迭代计算：zn+1 = zn^2 + c。\n在每次迭代中，我们将计算得到的结果作为下一次迭代的初始值，直到满足某个条件为止。如果在有限次迭代后，计算结果仍然保持有限，则认为该点属于曼德勃罗集合。\n4.1.1 初始化 # import pygame pygame.init() screen = pygame.display.set_mode((400, 400)) pygame.display.set_caption(\u0026#34;Mandelbrot set\u0026#34;) 4.1.2 绘制方法 # def fractal(): for y in range(400): for x in range(400): zx, zy = cx, cy = -2 + 2.5 * x / 400.0, -1.25 + 2.5 * y / 400.0 for i in range(25): zx, zy = zx * zx - zy * zy + cx, 2 * zx * zy + cy if zx * zx + zy * zy \u0026gt; 4: break screen.set_at((x, y), ((250 - 25 * i) * 0x10101)) pygame.display.update() 4.1.3 程序逻辑 # run = True while run: for event in pygame.event.get(): if event.type == pygame.QUIT: run = False screen.fill((255, 255, 255)) fractal() pygame.display.update() pygame.quit() 4.2 flappy Bird-游戏类 # Flappy Bird 是一款由越南游戏开发者Dong Nguyen开发的简单但受欢迎的手机游戏。游戏于2013年5月发布，迅速在全球范围内走红。\n游戏的玩法非常简单，玩家需要控制一只小鸟通过不断上下移动的管道障碍物。玩家通过点击屏幕使小鸟上升，松开手指则小鸟下降，需要巧妙地掌握时机和力度，避免撞到管道或掉落到地面上。游戏的目标是尽可能地飞过更多的管道，获取更高的分数。\n4.2.1 导入所需库以及初始化 # # 导入需要的库 import pygame from pygame.locals import * import random 4.2.2 窗体初始化 # pygame.init() clock = pygame.time.Clock() fps = 60 screen_width = 864 screen_height = 936 screen = pygame.display.set_mode((screen_width, screen_height)) pygame.display.set_caption(\u0026#39;Flappy Bird\u0026#39;) font = pygame.font.SysFont(\u0026#39;Bauhaus 93\u0026#39;, 60) white = (255, 255, 255) ground_scroll = 0 scroll_speed = 4 flying = False game_over = False pipe_gap = 150 pipe_frequency = 1500 last_pipe = pygame.time.get_ticks() - pipe_frequency score = 0 pass_pipe = False bg = pygame.image.load(\u0026#39;assets/flappybird/images/bg.png\u0026#39;) ground_img = pygame.image.load(\u0026#39;assets/flappybird/images/ground.png\u0026#39;) button_img = pygame.image.load(\u0026#39;assets/flappybird/images/restart.png\u0026#39;) 4.2.3 实体类 # \u0026#34;\u0026#34;\u0026#34; 小鸟类 \u0026#34;\u0026#34;\u0026#34; class Bird(pygame.sprite.Sprite): def __init__(self, x, y): pygame.sprite.Sprite.__init__(self) self.images = [] self.index = 0 self.counter = 0 for num in range(1, 4): img = pygame.image.load(f\u0026#39;assets/flappybird/images/bird{num}.png\u0026#39;) self.images.append(img) self.image = self.images[self.index] self.rect = self.image.get_rect() self.rect.center = [x, y] self.vel = 0 self.clicked = False def update(self): if flying == True: self.vel += 0.5 if self.vel \u0026gt; 8: self.vel = 8 if self.rect.bottom \u0026lt; 768: self.rect.y += int(self.vel) if game_over == False: if pygame.mouse.get_pressed()[0] == 1 and self.clicked == False: self.clicked = True self.vel = -10 if pygame.mouse.get_pressed()[0] == 0: self.clicked = False self.counter += 1 flap_cooldown = 5 if self.counter \u0026gt; flap_cooldown: self.counter = 0 self.index += 1 if self.index \u0026gt;= len(self.images): self.index = 0 self.image = self.images[self.index] self.image = pygame.transform.rotate(self.images[self.index], self.vel * -2) else: self.image = pygame.transform.rotate(self.images[self.index], -90) \u0026#34;\u0026#34;\u0026#34; 管道类 \u0026#34;\u0026#34;\u0026#34; class Pipe(pygame.sprite.Sprite): def __init__(self, x, y, position): pygame.sprite.Sprite.__init__(self) self.image = pygame.image.load(\u0026#39;assets/flappybird/images/pipe.png\u0026#39;) self.rect = self.image.get_rect() if position == 1: self.image = pygame.transform.flip(self.image, False, True) self.rect.bottomleft = [x, y - int(pipe_gap / 2)] if position == -1: self.rect.topleft = [x, y + int(pipe_gap / 2)] def update(self): self.rect.x -= scroll_speed if self.rect.right \u0026lt; 0: self.kill() \u0026#34;\u0026#34;\u0026#34; 界面按钮类 \u0026#34;\u0026#34;\u0026#34; class Button(): def __init__(self, x, y, image): self.image = image self.rect = self.image.get_rect() self.rect.topleft = (x, y) def draw(self): action = False pos = pygame.mouse.get_pos() if self.rect.collidepoint(pos): if pygame.mouse.get_pressed()[0] == 1: action = True screen.blit(self.image, (self.rect.x, self.rect.y)) return action 4.2.4 游戏逻辑 # \u0026#34;\u0026#34;\u0026#34; 初始化游戏对象 \u0026#34;\u0026#34;\u0026#34; bird_group = pygame.sprite.Group() pipe_group = pygame.sprite.Group() flappy = Bird(100, int(screen_height / 2)) bird_group.add(flappy) button = Button(screen_width // 2 - 50, screen_height // 2 - 100, button_img) \u0026#34;\u0026#34;\u0026#34; 绘制文字 \u0026#34;\u0026#34;\u0026#34; def draw_text(text, font, text_col, x, y): img = font.render(text, True, text_col) screen.blit(img, (x, y)) \u0026#34;\u0026#34;\u0026#34; 重置游戏 \u0026#34;\u0026#34;\u0026#34; def reset_game(): pipe_group.empty() flappy.rect.x = 100 flappy.rect.y = int(screen_height / 2) score = 0 return score \u0026#34;\u0026#34;\u0026#34; 游戏循环 \u0026#34;\u0026#34;\u0026#34; run = True while run: clock.tick(fps) screen.blit(bg, (0,0)) bird_group.draw(screen) bird_group.update() pipe_group.draw(screen) screen.blit(ground_img, (ground_scroll, 768)) if len(pipe_group) \u0026gt; 0: if bird_group.sprites()[0].rect.left \u0026gt; pipe_group.sprites()[0].rect.left\\ and bird_group.sprites()[0].rect.right \u0026lt; pipe_group.sprites()[0].rect.right\\ and pass_pipe == False: pass_pipe = True if pass_pipe == True: if bird_group.sprites()[0].rect.left \u0026gt; pipe_group.sprites()[0].rect.right: score += 1 pass_pipe = False draw_text(str(score), font, white, int(screen_width / 2), 20) if pygame.sprite.groupcollide(bird_group, pipe_group, False, False) or flappy.rect.top \u0026lt; 0: game_over = True if flappy.rect.bottom \u0026gt;= 768: game_over = True flying = False if not game_over and flying: time_now = pygame.time.get_ticks() if time_now - last_pipe \u0026gt; pipe_frequency: pipe_height = random.randint(-100, 100) btm_pipe = Pipe(screen_width, int(screen_height / 2) + pipe_height, -1) top_pipe = Pipe(screen_width, int(screen_height / 2) + pipe_height, 1) pipe_group.add(btm_pipe) pipe_group.add(top_pipe) last_pipe = time_now ground_scroll -= scroll_speed if abs(ground_scroll) \u0026gt; 35: ground_scroll = 0 pipe_group.update() if game_over: if button.draw() == True: game_over = False score = reset_game() for event in pygame.event.get(): if event.type == pygame.QUIT: run = False if event.type == pygame.MOUSEBUTTONDOWN and flying == False and game_over == False: flying = True pygame.display.update() pygame.quit() ","date":"2025-08-02","externalUrl":null,"permalink":"/thoughts/pygame-tutorials/","section":"随笔","summary":"","title":"Pygame入门到入土","type":"thoughts"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/python/","section":"标签","summary":"","title":"Python","type":"tags"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/%E7%BC%96%E7%A8%8B/","section":"标签","summary":"","title":"编程","type":"tags"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/","section":"标签","summary":"","title":"标签","type":"tags"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/%E6%95%99%E7%A8%8B/","section":"标签","summary":"","title":"教程","type":"tags"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/%E5%BC%80%E5%8F%91/","section":"标签","summary":"","title":"开发","type":"tags"},{"content":" 重要的不是结果，而是现在！ ","date":"2025-08-02","externalUrl":null,"permalink":"/thoughts/","section":"随笔","summary":"","title":"随笔","type":"thoughts"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/%E5%AD%A6%E4%B9%A0/","section":"标签","summary":"","title":"学习","type":"tags"},{"content":"","date":"2025-08-02","externalUrl":null,"permalink":"/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/","section":"标签","summary":"","title":"游戏开发","type":"tags"},{"content":" VR开发工具概述 # 日期: 2024-09-10\n最后修改: 2024-10-11\n作者: Z\n针对XR设备开发还处于初步发展阶段，缺乏统一的标准。不像PC或移动端，可以做到一次开发多设备部署，如移动端应用基于Android SDK开发后，就可以运行于绝大部分Android手机。\n一、XR通用开发框架 # 针对XR设备开发还处于初步发展阶段，缺乏统一的标准。不像PC或移动端，可以做到一次开发多设备部署，如移动端应用基于Android SDK开发后，就可以运行于绝大部分Android手机。\n越来越多的VR设备推出，控制器类型逐渐趋向于碎片化。从开发层面上来看，不同的控制器具有不同的键值映射，当现有 VR 应用程序移植到另外一个VR平台的时候，需要针对目标平台进行交互适配。\n每有新的控制器发布，都会给开发者带来一些额外的工作量，游戏项目需要修改交互代码以适配新的设备。\n随着XR内容生态的发展，这一问题得到了改善，主流引擎提供了统一的XR开发框架，开发者无需关注设备间差异，只需关注引擎，专注于内容创作本身，而复杂的设备和平台兼容将由底层的通用开发框架来负责。\n1.1 SteamVR Plugin # SteamVR Plugin 是 Valve 提供给 Unity 开发者的开发工具，主要帮助开发者实现三项主要功能：\n为 VR 控制器加载呈现相对应的 3D 模型 处理控制器的输入 根据用户实际手部动作估算骨骼数据并呈现手部姿态 此外，它还提供了交互系统（Interaction System），帮助开发者快速实现常见的 VR 交互功能。\n2.x 版本引入 Input System，开发者可以围绕动作（Action）而非设备按键编程，提高新设备的适配效率。\n1.2 MRTK # MRTK（Mixed Reality Toolkit）是微软提供的混合现实开发工具包，支持 Unreal Engine 与 Unity。\n主要特性包括：\n跨平台输入系统 空间交互构建模块 编辑器内模拟 模块化组件结构 MRTK v3 基于 OpenXR 原生构建，可运行在 HoloLens 2、Meta Quest 2、Magic Leap 2 等设备上。\n1.3 XR Interaction Toolkit # XR Interaction Toolkit 是 Unity 官方推出的 XR 开发工具包，提供跨平台的移动、抓取、UI 交互等功能。\n无需编写代码即可实现常见交互，也支持自定义扩展。\n最新版本增加了 Poke Interactor、Multi-grab Support 等新特性。\n1.4 Unreal Engine # UE（Unreal Engine）在 VR 领域画面与沉浸感表现出色，支持：\nOpenXR、SteamVR、MRTK Oculus、三星、谷歌等厂商插件 VR 游戏交互、UI、优化与平台发布流程 1.5 Godot # Godot 从 3.0 开始支持 VR，4.0 将 OpenXR 集成进引擎，支持 Quest 2、Pico 4、Magic Leap 2 等。\n推荐使用官方 Godot XR Tools 插件，提供移动、交互、UI 等模块及项目模板。\n1.6 VRTK # VRTK（Virtual Reality Toolkit）是 Unity VR 交互开发框架，支持 Oculus、SteamVR、Daydream 等平台。\nV4 完全重写，模块化、硬件无关，便于跨平台适配。\n二、XR设备SDK # 即使有通用框架，由于 OpenXR 兼容性不足，各大厂商仍会提供自家 SDK 供开发者使用。\n2.1 Oculus Integration # Meta 提供的 Unity 插件，支持 Quest 系列设备，集成：\n渲染功能 社交系统 头像系统 音频与语音 示例框架 2.2 Pico SDK # Pico 针对 Neo 3、Pico 4 提供 SDK，支持渲染、输入、追踪、MR 捕捉，并配套支付与数据体系。\n2.3 HTC SDK # 支持 Vive 系列设备，提供指尖追踪、手势识别插件，可用于 Unity/Unreal。\n2.4 GoogleVR SDK # 分为 Cardboard 与 Daydream 两种方案，支持头部追踪、立体渲染、畸变修正、控制器支持等功能。\n","date":"2024-09-10","externalUrl":null,"permalink":"/thoughts/vr-dev-tool/","section":"随笔","summary":"","title":"VR开发概述","type":"thoughts"},{"content":"","date":"2024-09-10","externalUrl":null,"permalink":"/tags/%E7%8E%AF%E5%A2%83/","section":"标签","summary":"","title":"环境","type":"tags"},{"content":"","date":"2024-09-10","externalUrl":null,"permalink":"/tags/%E9%85%8D%E7%BD%AE/","section":"标签","summary":"","title":"配置","type":"tags"},{"content":"","date":"2023-02-11","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2023-02-11","externalUrl":null,"permalink":"/tags/hololens-2/","section":"标签","summary":"","title":"Hololens 2","type":"tags"},{"content":" 本文为笔者从首次拿到设备开箱到配置开发环境，最后对项目进行打包部署到Hololens2真机的整个流程。\n微软的官方文档中有HoloLens2部署的权威教程。但一些问题官方文档并没有列出，需要在实际开发过程中去根据自身或者前人的经验去解决。\n开发环境使用Unity2020.3.8+ MRTK2.7.0。MRTK2.7 已在2021年9月份开始支持Unity2020.3LTS版本，通常而言，Unity2019.4+MRTK2.6 或者 Unity2020.3+MRTK2.7是最佳搭配，不建议混合搭配（如Unity2019.4+MRTK2.7）。\n一、开发环境搭建 # 1.1 Unity配置 # Unity是开发 HoloLens 应用的重点平台，而微软和 Unity 本身也是紧密合作，双向支持。\n1.1.1 新建Unity项目 # 通过Unity Hub，新建一个工程，选择3D模板、填写好项目名称、选择工程存储路径。\n1.1.2 配置Unity编译环境 # 工程创建完成后，在Unity菜单中，依次选择File \u0026gt; Build Settings（快捷键Ctrl+Shift+B），打开构建设置窗口，选择“Universal Windows Platform”，设置：\nTarget Device: HoloLens Architecture: ARM64 点击「Switch Platform」按钮切换平台。\n如果无法选择UWP，需要回到Unity Hub中为该版本添加UWP构建支持模块。\n1.2 导入MRTK插件 # 1.2.1 导入方式 # 方式一：从官方Github 下载 .unitypackage 方式二（推荐）：使用 MRFT 工具 以可视化方式管理MRTK 1.2.2 使用MRFT导入MRTK # 打开 MRFT 工具，指定 Unity 工程路径 选择 Mixed Reality Toolkit Foundation 并指定版本 勾选 Mixed Reality OpenXR Plugin 并指定版本 MRFT 会修改 manifest.json，Unity 会自动加载对应工具包 1.2.3 配置XR环境 # 启用 Unity OpenXR 插件 重启 Unity（导入OpenXR插件后会提示） 打开 XR Plug-in Management 设置 在 UWP 下勾选 OpenXR，并勾选 Microsoft HoloLens feature group Player Settings 配置： Package name：自定义 Capabilities：InternetClient、InternetClientServer、WebCam、Microphone、SpatialPerception Supported Device Families：Holographic OpenXR 配置： Render Mode: Single Pass Instance Depth Submission Mode: Depth 16 Bit 添加 Microsoft Hand Interaction Profile 1.2.4 完成XR环境 # 最后导入 TextMeshPro 工具包完成环境配置。\n二、设备环境 # 2.1 启动开发者模式 # PC：控制面板 → 更新和安全 → 开发者选项 → 开启开发者模式 HoloLens2：Settings → Update \u0026amp; Security → For Developers → 开启 Developer Mode 2.2 网页连接HoloLens2设备 # 获取UsbNcm IP 方式一：USB-C 连接 → 在开发者面板查看 方式二：命令行执行 winappdeploycmd device 浏览器访问 IP → 安装证书 → 输入设备Pin → 注册用户 登录 Device Portal 查看状态 三、MR 场景与本机调试 # 3.1 创建MR场景 # 菜单 Mixed Reality \u0026gt; Toolkit \u0026gt; Add to Scene and Configure\n会自动生成：\nMixedRealityToolkit MixedRealityPlayspace MixedRealitySceneContent 3.2 添加手势交互 # 创建 Cube 添加： Object Manipulator NearInteractionGrabbable 运行程序，即可手势交互 3.3 本机调试 # USB：USB-C 直连 WiFi：Mixed Reality \u0026gt; Remoting → 输入IP → Enable → 运行 四、项目打包部署 # 4.1 Unity 编译 # Build Settings → 输出到本地文件夹\n4.2 VS WiFi 部署 # 同一局域网 VS 打开工程 → Release / ARM64 / Remote Machine 填写 IP，身份验证类型：通用 F5 部署（首次需输入 Pin） 参考文章 # 使用 Windows 设备门户 Unity X HoloLens 2 混合现实开发入门 HoloLens2之路－Unity2020.3+MRTK2.7配置 HoloLens2之路－部署到真机 ","date":"2023-02-11","externalUrl":null,"permalink":"/thoughts/hololens/","section":"随笔","summary":"","title":"Hololens 2开发笔记","type":"thoughts"},{"content":"","date":"2023-02-11","externalUrl":null,"permalink":"/tags/vr/","section":"标签","summary":"","title":"VR","type":"tags"},{"content":"","date":"2023-02-11","externalUrl":null,"permalink":"/categories/%E6%83%B3%E6%B3%95/","section":"Categories","summary":"","title":"想法","type":"categories"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/tags/jazz/","section":"标签","summary":"","title":"Jazz","type":"tags"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/topics/","section":"Topics","summary":"","title":"Topics","type":"topics"},{"content":"","externalUrl":null,"permalink":"/tags/%E5%89%8D%E7%AB%AF/","section":"标签","summary":"","title":"前端","type":"tags"},{"content":" 2025-05-07 13:07 我一直抵抗着那股要带走自己的洪流，却真正地随回忆一起融化在了时间里。\n2025-05-06 15:14 怎么会喜欢一个不存在的东西，世界上哪有正方体，只有我心爱的正方形。\n2025-03-01 14:14 死亡不是终点\n2024-10-18 00:14 深夜蹲大同新专辑\n2023-03-18 14:46 more care. more scare.\n2025-02-10 06:20 表达的冲动只是喉头一痒，清清嗓子便没了开口的欲望。\n2023-01-13 20:52 To be alone, you need someone to be alone from.\n2023-01-06 15:59 越喜欢某样东西，当失去时，失落感也将越强烈。\n2022-07-13 21:40 当这个世界被人类的期待填满，我唯有将自己的回忆细细珍藏。\n2018-03-29 12:10 I liked how things were when they were.\n","externalUrl":null,"permalink":"/murmur/","section":"","summary":"","title":"碎碎念","type":"page"},{"content":"","externalUrl":null,"permalink":"/tags/%E9%9F%B3%E4%B9%90/","section":"标签","summary":"","title":"音乐","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/%E6%B8%B8%E6%88%8F/","section":"标签","summary":"","title":"游戏","type":"tags"}]